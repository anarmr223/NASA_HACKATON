<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <title>GLTF Hover + Impacto de Asteroide 3D</title>
  <meta name='viewport' content='width=device-width, initial-scale=1'>

  <script src="JS/three.min.js"></script>
  <script src="JS/OrbitControls.js"></script>
  <script src="JS/GLTFLoader.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }

    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      font-family: sans-serif;
      z-index: 9999;
      transition: opacity 0.5s;
    }
  </style>
</head>

<body>
  <h1 style="color: white; position: absolute; top: 10px; left: 10px; z-index: 100;">Asteroyer TEAM</h1>

  <div id="loading-screen">
    <p>Cargando Modelos y Texturas...</p>
    <div id="progress-text">0%</div>
  </div>

  <div id="controls-panel" style="
        position: absolute; top: 10px; right: 10px; background: rgba(30,30,30,0.8);
        padding: 12px; border-radius: 8px; color: white; z-index: 100;">
    <h3 style="margin:0 0 8px 0;">Controles</h3>
    <div>
      <label>Latitud impacto: <input type="range" id="IMPACTO_LAT_RANGE" min="-90" max="90" step="0.1"
          value="40.4"></label>
    </div>
    <div>
      <label>Longitud impacto: <input type="range" id="IMPACTO_LON_RANGE" min="-180" max="180" step="0.1"
          value="-3.7"></label>
    </div>

    <div style="margin-top: 10px;">
      <label>
        Mover Cámara al Impacto:
        <input type="checkbox" id="moverCamara" checked>
      </label>
    </div>
    <div>
      <label>Cámara Z: <input type="range" id="camz" min="-10" max="100" step="0.1" value="80"></label>
    </div>
    <div>
      <button id="iniciarImpacto" style="margin-top: 10px; padding: 5px 10px;">Reiniciar Impacto</button>
    </div>
  </div>


  <div id="info-card" style="
    position: absolute;
    top: 60px;
    left: 10px;
    width: 300px;
    background: rgba(0, 0, 0, 0.7); /* negro semitransparente */
    color: white;
    padding: 10px;
    border-radius: 8px;
    display: none;
    z-index: 200;">
      
      <h4 id="asteroid-name"></h4>
      <p><strong>ID:</strong> <span id="asteroid-id"></span></p>
      <p><strong>Peligroso:</strong> <span id="asteroid-hazardous"></span></p>
      <p><strong>Diámetro:</strong> <span id="asteroid-diameter"></span></p>
      <p><strong>Masa:</strong> <span id="asteroid-mass"></span></p>
      <p><strong>Velocidad:</strong> <span id="asteroid-velocity"></span></p>
      <p><strong>Distancia a la Tierra:</strong> <span id="asteroid-distance"></span></p>

      <button id="close-card" style="margin-top:10px;">Cerrar</button>
  </div>



  <script>
    // ==========================================
    // 1. VARIABLES GLOBALES
    // ==========================================
    let camera, scene, renderer, controls, raycaster;
    let pointer = new THREE.Vector2();
    let INTERSECTED = null;
    let intersectables = [];
    let asteroide1 = null,
      asteroide2 = null,
      tierra = null,
      crater = null;

    const totalResources = 3;
    let resourcesLoaded = 0;
    const loadingScreen = document.getElementById('loading-screen');
    const progressText = document.getElementById('progress-text');

    // VARIABLES DE IMPACTO (Valores para España)
    let TIERRA_RADIO = 50;
    const TIERRA_CENTER = new THREE.Vector3(0, 0, -25);
    const DISTANCIA_INICIAL_ASTEROIDE = 75;
    let IMPACTO_LAT = 40.4;
    let IMPACTO_LON = -3.7;
    let radio_impacto = 1; //km
    // ✅ VARIABLE DE CONTROL DE CÁMARA
    let MOVE_CAMERA_ON_IMPACT = true;

    // Variables de posición de la cámara ajustadas
    const CAMERA_DISTANCE = 70;
    const CAMERA_HEIGHT = 20;

    let startPosition = new THREE.Vector3();
    let targetPosition = new THREE.Vector3();
    let animationClock = 0;
    const ANIMATION_DURATION = 150;
    let isImpactScheduled = false;

    // ==========================================
    // 2. FUNCIONES DE LÓGICA
    // ==========================================

    function latLonToVector3(lat, lon, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    function updateLoadingState() {
      resourcesLoaded++;
      if (resourcesLoaded === totalResources) {
        loadingScreen.style.opacity = 0;
        setTimeout(() => {
          loadingScreen.style.display = 'none';
          if (tierra && asteroide1) setupImpact();
        }, 500);
      }
    }

    function setupImpact() {
      animationClock = 0;

      // 1. Cálculo del vector de dirección y posiciones
      const dir = latLonToVector3(IMPACTO_LAT, IMPACTO_LON, 1).normalize();
      targetPosition = TIERRA_CENTER.clone().add(dir.clone().multiplyScalar(TIERRA_RADIO));
      startPosition = TIERRA_CENTER.clone().add(dir.clone().multiplyScalar(TIERRA_RADIO + DISTANCIA_INICIAL_ASTEROIDE));

      // 2. Rotación de la Tierra
      tierra.rotation.y = -IMPACTO_LON * (Math.PI / 180);

      // 3. Posicionar Asteroide y apuntar
      asteroide1.position.copy(startPosition);
      asteroide1.lookAt(targetPosition);
      asteroide1.scale.set(1, 1, 1);

      // ✅ Reiniciar el cráter
      if (crater) {
        // Posicionar el cráter exactamente en el punto de impacto
        crater.position.copy(targetPosition);

        // Rotar el cráter para que mire hacia afuera de la Tierra (alineado con la normal)
        crater.lookAt(targetPosition.clone().add(dir));

        // Colocar la escala a cero para la animación inicial
        crater.scale.set(0.001, 0.001, 0.001);
      }

      // ✅ 4. Ajustar la cámara SOLO si la variable de control está en true
      if (MOVE_CAMERA_ON_IMPACT) {
        let cameraPositionVector = dir.clone().multiplyScalar(CAMERA_DISTANCE);
        cameraPositionVector.y += CAMERA_HEIGHT;

        // Posicionar la cámara
        camera.position.copy(TIERRA_CENTER).add(cameraPositionVector);

        // Centrar los controles (el punto de mira) en el punto de impacto
        controls.target.copy(targetPosition);
        controls.update();
      }

      isImpactScheduled = true;
    }

    // ==========================================
    // 3. INICIALIZACIÓN DE THREE.JS
    // ==========================================

    scene = new THREE.Scene();
    const cubeTextureLoader = new THREE.CubeTextureLoader();
    scene.background = cubeTextureLoader.load([
      'modelos/skybox/right_1.jpg',
      'modelos/skybox/left_1.jpg',
      'modelos/skybox/up_1.jpg',
      'modelos/skybox/down_1.jpg',
      'modelos/skybox/front_1.jpg',
      'modelos/skybox/back_1.jpg'
    ]);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 80); // Posición inicial de cámara

    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(50, 50, 50);
    directionalLight.intensity = 5;
    scene.add(directionalLight);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.copy(TIERRA_CENTER);
    controls.update();

    raycaster = new THREE.Raycaster();

    const loader = new THREE.GLTFLoader();

    // Carga 1: Tierra
    loader.load('modelos/earth.gltf', gltf => {
      tierra = gltf.scene;
      tierra.scale.set(10, 10, 10);
      tierra.position.copy(TIERRA_CENTER);
      scene.add(tierra);

      const box = new THREE.Box3().setFromObject(tierra);
      const size = new THREE.Vector3();
      box.getSize(size);
      TIERRA_RADIO = Math.max(size.x, size.y, size.z) / 2;

      updateLoadingState();
    });
    const CRATER_MATERIAL = new THREE.MeshStandardMaterial({
      color: 0xff0000,      // Color rojo para simular el cráter
      metalness: 0.0,       // No es metálico
      roughness: 1.0,       // Muy rugoso para evitar brillos (el principal causante del "blanco")
      // Se elimina 'emissive' y 'emissiveIntensity' para que no emita luz propia.
    });


    // Usaremos una geometría simple (un cilindro o un cono invertido simple)
    const CRATER_GEOMETRY = new THREE.CylinderGeometry(1, 4, 0.5, 32);
    CRATER_GEOMETRY.rotateX(Math.PI / 2); // Orientar para que sea plano en XZ

    crater = new THREE.Mesh(CRATER_GEOMETRY, CRATER_MATERIAL);
    crater.position.set(0, -1000, 0); // Oculto inicialmente
    crater.scale.set(0.001, 0.001, 0.001); // Escala mínima
    scene.add(crater);

    // Carga 2 & 3: Asteroides
    const asteroidModels = [
      { url: 'modelos/ASTEROID1.gltf', objRef: () => asteroide1, position: null },
      { url: 'modelos/ASTEROID2.gltf', objRef: () => asteroide2, position: null }
    ];

    asteroidModels.forEach((data, i) => {
      loader.load(data.url, gltf => {
        const obj = gltf.scene;
        obj.scale.set(1, 1, 1);
        if (i === 0) {
          obj.position.set(-1000, -1000, -1000);
        } else {
          obj.position.set(10, 10, 10);
        }

        obj.traverse(child => {
          if (child.isMesh) child.userData.originalEmissive = child.material.emissive.getHex();
        });

        scene.add(obj);
        intersectables.push(obj);
        if (i === 0) asteroide1 = obj;
        else asteroide2 = obj;
        updateLoadingState();
      });
    });

    // ==========================================
    // 4. EVENTOS
    // ==========================================

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.addEventListener("mousemove", e => {
      pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    //TARJETA DE INFORMACION ASTEROIDE
    document.addEventListener('click', () => {
    raycaster.setFromCamera(pointer, camera);
    const intersects = raycaster.intersectObjects(intersectables, true);

    if (intersects.length > 0) {
        const clickedObject = intersects[0].object;
        const card = document.getElementById('info-card');

        // Aquí asumimos que los datos vienen de userData cuando creas el objeto 3D
        const data = clickedObject.userData || {};

        // Rellenar tarjeta
        document.getElementById('asteroid-name').textContent = data.name || 'Asteroide';
        document.getElementById('asteroid-id').textContent = data.id || 'Desconocido';
        document.getElementById('asteroid-hazardous').textContent = data.hazardous ? 'Sí' : 'No';
        document.getElementById('asteroid-diameter').textContent = data.diameter ? data.diameter + ' m' : 'N/D';
        document.getElementById('asteroid-mass').textContent = data.mass ? data.mass + ' kg' : 'N/D';
        document.getElementById('asteroid-velocity').textContent = data.velocity ? data.velocity + ' km/h' : 'N/D';
        document.getElementById('asteroid-distance').textContent = data.distance ? data.distance + ' km' : 'N/D';

        // Mostrar tarjeta
        card.style.display = 'block';
    }
});

// Cerrar tarjeta
document.getElementById('close-card').addEventListener('click', () => {
    document.getElementById('info-card').style.display = 'none';
});


// Cerrar tarjeta
document.getElementById('close-card').addEventListener('click', () => {
    document.getElementById('info-card').style.display = 'none';
});


    // Sliders de Control
    document.getElementById('IMPACTO_LAT_RANGE').addEventListener('input', e => { IMPACTO_LAT = parseFloat(e.target.value); });
    document.getElementById('IMPACTO_LON_RANGE').addEventListener('input', e => { IMPACTO_LON = parseFloat(e.target.value); });
    document.getElementById('camz').addEventListener('input', e => { camera.position.z = parseFloat(e.target.value); camera.updateProjectionMatrix(); });

    // ✅ EVENTO PARA EL NUEVO CHECKBOX
    document.getElementById('moverCamara').addEventListener('change', e => {
      MOVE_CAMERA_ON_IMPACT = e.target.checked;
    });

    // Botón de Impacto
    document.getElementById('iniciarImpacto').addEventListener('click', () => {
      if (tierra && asteroide1) setupImpact();
    });


    // ==========================================
    // 5. ANIMACIÓN (LOOP)
    // ==========================================

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // Lógica de Hover (Raycasting)
      raycaster.setFromCamera(pointer, camera);
      let intersectedNow = null;
      for (let obj of intersectables) {
        const intersects = raycaster.intersectObject(obj, true);
        if (intersects.length > 0) {
          intersectedNow = obj;
          break;
        }
      }

      if (intersectedNow !== INTERSECTED) {
        if (INTERSECTED) INTERSECTED.traverse(child => {
          if (child.isMesh) child.material.emissive.setHex(child.userData.originalEmissive);
        });

        INTERSECTED = intersectedNow;
        if (INTERSECTED) INTERSECTED.traverse(child => {
          if (child.isMesh) child.material.emissive.setHex(0xff0000); // Color rojo
        });
      }

      // Lógica de Impacto
      if (isImpactScheduled && asteroide1) {
        if (animationClock < ANIMATION_DURATION) {
          animationClock++;
          const t = animationClock / ANIMATION_DURATION;
          asteroide1.position.lerpVectors(startPosition, targetPosition, t);
        } else if (animationClock === ANIMATION_DURATION) {
          isImpactScheduled = false;
          asteroide1.position.copy(targetPosition);
          asteroide1.scale.set(0.1, 0.1, 0.1);
          console.log("¡IMPACTO!");

          // ✅ Lógica de escalado del cráter
          if (crater) {
            // Escala base, puedes usar la escala original del asteroide para referencia,
            // o un valor fijo para probar, como 10
            const CRATER_SIZE = 0.5;
            crater.scale.set(CRATER_SIZE, CRATER_SIZE, CRATER_SIZE);
          }
        }
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>

</html>
